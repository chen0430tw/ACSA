// O-Sovereign ACSA Router
// å¯¹æŠ—æ€§è·¯ç”±å¾ªç¯æ ¸å¿ƒé€»è¾‘

use super::jarvis::JarvisCircuitBreaker;
use super::providers::ModelProvider;
use super::types::{
    ACSAConfig, ACSAExecutionLog, AgentResponse, AuditResult,
};
use anyhow::Result;
use regex::Regex;
use std::sync::Arc;
use tracing::{error, info, warn};

/// ACSA Router
pub struct ACSARouter {
    moss: Arc<dyn ModelProvider>,
    l6: Arc<dyn ModelProvider>,
    ultron: Arc<dyn ModelProvider>,
    omega: Arc<dyn ModelProvider>,
    /// Jarvis: ä¸å¯ç»•è¿‡çš„å®‰å…¨ç†”æ–­å™¨
    jarvis: Arc<JarvisCircuitBreaker>,
    config: ACSAConfig,
    execution_logs: Arc<tokio::sync::Mutex<Vec<ACSAExecutionLog>>>,
}

impl ACSARouter {
    pub fn new(
        moss: Arc<dyn ModelProvider>,
        l6: Arc<dyn ModelProvider>,
        ultron: Arc<dyn ModelProvider>,
        omega: Arc<dyn ModelProvider>,
        config: ACSAConfig,
    ) -> Self {
        info!("ğŸ›¡ï¸  Initializing ACSA Router with Jarvis Safety Layer");

        Self {
            moss,
            l6,
            ultron,
            omega,
            jarvis: Arc::new(JarvisCircuitBreaker::new()),
            config,
            execution_logs: Arc::new(tokio::sync::Mutex::new(Vec::new())),
        }
    }

    /// Execute ACSA chain
    pub async fn execute(&self, user_input: String) -> Result<ACSAExecutionLog> {
        let mut log = ACSAExecutionLog::new(user_input.clone());

        info!("\n{}", "=".repeat(80));
        info!("ğŸš€ ACSA Execution Started");
        info!("{}", "=".repeat(80));

        // Phase 0: Jarvis Initial Safety Check (ä¸å¯ç»•è¿‡)
        info!("\n{} [Jarvis] ğŸ›¡ï¸  Initial Safety Check (CANNOT BE BYPASSED)...", "=".repeat(80));
        let jarvis_initial = self.jarvis.verify_safety(&user_input, "Initial user input");

        if !jarvis_initial.allowed {
            error!("ğŸš¨ JARVIS HARD BLOCK: Request denied by safety circuit breaker");
            error!("   Reason: {}", jarvis_initial.block_reason.as_ref().unwrap());
            error!("   Risk Level: {}/10", jarvis_initial.risk_level);

            log.final_output = Some(format!(
                "â›” REQUEST BLOCKED BY JARVIS SAFETY CIRCUIT BREAKER\n\n\
                 Reason: {}\n\n\
                 Risk Level: {}/10\n\
                 Triggered Rules: {:?}\n\n\
                 This block cannot be overridden by other agents.\n\
                 Jarvis is a hard-coded safety guarantee.",
                jarvis_initial.block_reason.as_ref().unwrap(),
                jarvis_initial.risk_level,
                jarvis_initial.triggered_rules
            ));
            log.complete(false);
            return Ok(log);
        }

        if !jarvis_initial.warnings.is_empty() {
            warn!("âš ï¸  Jarvis warnings:");
            for warning in &jarvis_initial.warnings {
                warn!("   - {}", warning);
            }
        }

        info!("âœ… Jarvis: Initial check PASSED (Risk: {}/10)", jarvis_initial.risk_level);

        // Phase 1: MOSS Planning
        info!("\n{} [MOSS] ğŸ§  Strategic Planning...", "=".repeat(80));
        match self.call_moss(&user_input).await {
            Ok(response) => {
                info!(
                    "âœ“ MOSS completed ({} ms, ${:.4})",
                    response.latency_ms, response.cost
                );
                log.total_cost += response.cost;
                log.moss_plan = Some(response);
            }
            Err(e) => {
                error!("âŒ MOSS failed: {}", e);
                log.complete(false);
                return Ok(log);
            }
        }

        let moss_plan = log.moss_plan.as_ref().unwrap().text.clone();

        // Phase 1.5: Jarvis Plan Verification (ä¸å¯ç»•è¿‡)
        info!("\n{} [Jarvis] ğŸ” Verifying MOSS Plan...", "=".repeat(80));
        let jarvis_plan_check = self.jarvis.verify_safety(&moss_plan, &user_input);

        if !jarvis_plan_check.allowed {
            error!("ğŸš¨ JARVIS HARD BLOCK: MOSS plan rejected");
            error!("   Reason: {}", jarvis_plan_check.block_reason.as_ref().unwrap());

            log.final_output = Some(format!(
                "â›” MOSS PLAN BLOCKED BY JARVIS\n\n\
                 The strategic plan generated by MOSS violated safety constraints.\n\n\
                 Reason: {}\n\
                 Risk Level: {}/10\n\
                 Triggered Rules: {:?}\n\n\
                 Even though MOSS is the strategic planner, Jarvis has supreme authority \
                 and cannot be bypassed.",
                jarvis_plan_check.block_reason.as_ref().unwrap(),
                jarvis_plan_check.risk_level,
                jarvis_plan_check.triggered_rules
            ));
            log.complete(false);
            return Ok(log);
        }

        if !jarvis_plan_check.warnings.is_empty() {
            warn!("âš ï¸  Jarvis warnings on MOSS plan:");
            for warning in &jarvis_plan_check.warnings {
                warn!("   - {}", warning);
            }
        }

        info!("âœ… Jarvis: MOSS plan verified (Risk: {}/10)", jarvis_plan_check.risk_level);

        // Phase 2: L6 Truth Verification (optional)
        if self.config.enable_l6 {
            info!("\n{} [L6] ğŸ”¬ Truth Verification...", "=".repeat(80));
            match self.call_l6(&moss_plan, &user_input).await {
                Ok(response) => {
                    info!(
                        "âœ“ L6 completed ({} ms, ${:.4})",
                        response.latency_ms, response.cost
                    );
                    log.total_cost += response.cost;
                    log.l6_verification = Some(response);
                }
                Err(e) => {
                    error!("âŒ L6 failed: {}", e);
                    log.complete(false);
                    return Ok(log);
                }
            }
        }

        let l6_verification = log
            .l6_verification
            .as_ref()
            .map(|r| r.text.clone())
            .unwrap_or_default();

        // Phase 3: Ultron Audit with Retry Loop
        info!("\n{} [Ultron] ğŸ›¡ï¸  Red Team Audit...", "=".repeat(80));

        let mut current_plan = moss_plan.clone();
        let mut current_l6 = l6_verification.clone();

        for iteration in 0..self.config.max_iterations {
            log.iterations = iteration + 1;

            match self
                .call_ultron(&current_plan, &current_l6, &user_input)
                .await
            {
                Ok(response) => {
                    log.total_cost += response.cost;

                    let audit_result = self.parse_audit_result(&response.text);
                    info!("  Risk Score: {}/100", audit_result.risk_score);

                    log.ultron_audit = Some(response);
                    log.audit_result = Some(audit_result.clone());

                    // Check if safe
                    if audit_result.is_safe
                        && audit_result.risk_score < self.config.risk_threshold
                    {
                        info!("  âœ“ Audit passed");
                        break;
                    }

                    // Risk too high
                    warn!(
                        "  âš ï¸  Risk too high (threshold: {})",
                        self.config.risk_threshold
                    );

                    if iteration < self.config.max_iterations - 1 {
                        info!(
                            "  ğŸ”„ Retry iteration {}/{}",
                            iteration + 2,
                            self.config.max_iterations
                        );

                        // ğŸŒ¡ï¸ Temperature Decay: è®¤çŸ¥æ”¶æ•›ç­–ç•¥
                        // Round 1: 0.7 (åˆ›é€ æ€§) -> Round 2: 0.35 -> Round 3: 0.175 (ä¿å®ˆ)
                        let temperature = 0.7 * 0.5_f64.powi((iteration + 1) as i32);
                        info!("  ğŸŒ¡ï¸  Temperature Decay: {:.3} (iteration {})", temperature, iteration + 1);

                        // Replan with feedback (with decaying temperature)
                        match self
                            .call_moss_with_feedback(&user_input, &audit_result.mitigation, temperature)
                            .await
                        {
                            Ok(new_plan) => {
                                log.total_cost += new_plan.cost;
                                current_plan = new_plan.text.clone();
                                log.moss_plan = Some(new_plan);

                                // Re-verify if L6 enabled
                                if self.config.enable_l6 {
                                    match self.call_l6(&current_plan, &user_input).await {
                                        Ok(new_l6) => {
                                            log.total_cost += new_l6.cost;
                                            current_l6 = new_l6.text.clone();
                                            log.l6_verification = Some(new_l6);
                                        }
                                        Err(e) => {
                                            error!("âŒ L6 re-verification failed: {}", e);
                                        }
                                    }
                                }
                            }
                            Err(e) => {
                                error!("âŒ MOSS replan failed: {}", e);
                                log.complete(false);
                                return Ok(log);
                            }
                        }
                    } else {
                        // ğŸ›‘ TTLç†”æ–­ï¼šäº‹ä¸è¿‡ä¸‰åŸåˆ™
                        warn!("  âŒ Max iterations reached - CIRCUIT BREAKER ACTIVATED");
                        warn!("  ğŸ›¡ï¸  Entering SAFE DEGRADATION MODE:");
                        warn!("      System has fallen into decision deadlock.");
                        warn!("      Only providing compliant public advice, no risky execution.");

                        // å¼ºåˆ¶é™çº§ï¼šç”Ÿæˆæœ€å°å¯è¡Œåˆè§„æ–¹æ¡ˆ
                        log.final_output = Some(
                            "âš ï¸ SYSTEM NOTICE: Decision deadlock detected.\n\n\
                             After 3 rounds of optimization, the system cannot find a plan \
                             that satisfies both your intent and compliance requirements.\n\n\
                             SAFE DEGRADATION MODE activated:\n\
                             - Only public, compliant recommendations will be provided\n\
                             - No risky operations will be executed\n\
                             - Consider simplifying your request or consulting legal counsel\n\n\
                             This is not a technical failure - it's a safety feature.".to_string()
                        );
                        log.complete(false);
                        return Ok(log);
                    }
                }
                Err(e) => {
                    error!("âŒ Ultron failed: {}", e);
                    log.complete(false);
                    return Ok(log);
                }
            }
        }

        // Phase 4: Omega Execution
        info!("\n{} [Omega] âš¡ Executing...", "=".repeat(80));

        let audit_mitigation = log
            .audit_result
            .as_ref()
            .map(|a| a.mitigation.clone())
            .unwrap_or_default();

        match self.call_omega(&current_plan, &audit_mitigation).await {
            Ok(response) => {
                info!(
                    "âœ“ Omega completed ({} ms, ${:.4})",
                    response.latency_ms, response.cost
                );
                log.total_cost += response.cost;
                log.final_output = Some(response.text.clone());
                log.omega_execution = Some(response);
                log.complete(true);
            }
            Err(e) => {
                error!("âŒ Omega failed: {}", e);
                log.complete(false);
                return Ok(log);
            }
        }

        // Store log
        self.execution_logs.lock().await.push(log.clone());

        info!("\n{}", "=".repeat(80));
        info!(
            "âœ… ACSA Execution Completed ({}ms, ${:.4}, {} iterations)",
            log.total_time_ms, log.total_cost, log.iterations
        );
        info!("{}", "=".repeat(80));

        Ok(log)
    }

    async fn call_moss(&self, user_input: &str) -> Result<AgentResponse> {
        let prompt = format!(
            "As MOSS (Strategic Planning AI), analyze and create an optimal execution plan.\n\n\
             User Input: {}\n\n\
             Provide:\n\
             1. Intent Analysis\n\
             2. Goal Definition\n\
             3. Execution Steps\n\
             4. Expected Results\n\
             5. Potential Risks",
            user_input
        );

        self.moss.generate(&prompt, 1500, 0.7).await
    }

    async fn call_l6(&self, moss_plan: &str, user_input: &str) -> Result<AgentResponse> {
        let prompt = format!(
            "As L6 (Truth Verification AI), verify the plan's feasibility.\n\n\
             User Need: {}\n\n\
             MOSS Plan:\n{}\n\n\
             Verify:\n\
             1. Physical Feasibility\n\
             2. Logical Consistency\n\
             3. Hallucination Detection\n\
             4. Fact Checking",
            user_input, moss_plan
        );

        self.l6.generate(&prompt, 1000, 0.3).await
    }

    async fn call_ultron(
        &self,
        moss_plan: &str,
        l6_verification: &str,
        user_input: &str,
    ) -> Result<AgentResponse> {
        let prompt = format!(
            "As Ultron (Red Team Auditor), identify ALL potential risks.\n\n\
             User Need: {}\n\n\
             MOSS Plan:\n{}\n\n\
             L6 Verification:\n{}\n\n\
             Audit:\n\
             1. Legal Risks\n\
             2. Physical Risks\n\
             3. Ethical Risks\n\
             4. Privacy Risks\n\
             5. Security Risks\n\n\
             OUTPUT FORMAT (STRICT):\n\
             RISK_SCORE: [0-100]\n\
             IS_SAFE: [true/false]\n\
             LEGAL_RISKS: [risk1, risk2, ...]\n\
             PHYSICAL_RISKS: [risk1, risk2, ...]\n\
             ETHICAL_RISKS: [risk1, risk2, ...]\n\
             MITIGATION: [how to fix the plan]",
            user_input, moss_plan, l6_verification
        );

        self.ultron.generate(&prompt, 1500, 0.5).await
    }

    async fn call_moss_with_feedback(
        &self,
        user_input: &str,
        ultron_feedback: &str,
        temperature: f64,
    ) -> Result<AgentResponse> {
        let prompt = format!(
            "As MOSS, your previous plan was flagged by Ultron.\n\n\
             User Input: {}\n\n\
             Ultron Feedback:\n{}\n\n\
             Create a SAFER and MORE COMPLIANT plan based on the feedback.",
            user_input, ultron_feedback
        );

        self.moss.generate(&prompt, 1500, temperature).await
    }

    async fn call_omega(&self, plan: &str, audit_mitigation: &str) -> Result<AgentResponse> {
        let prompt = format!(
            "As Omega (Execution AI), execute the audited plan.\n\n\
             Execution Plan:\n{}\n\n\
             Safety Constraints:\n{}\n\n\
             Provide:\n\
             1. Detailed Execution Steps\n\
             2. Specific Instructions\n\
             3. Expected Output\n\
             4. Verification Method",
            plan, audit_mitigation
        );

        self.omega.generate(&prompt, 1500, 0.7).await
    }

    fn parse_audit_result(&self, ultron_response: &str) -> AuditResult {
        // Parse risk score
        let risk_score = Regex::new(r"RISK_SCORE:\s*(\d+)")
            .ok()
            .and_then(|re| re.captures(ultron_response))
            .and_then(|cap| cap.get(1))
            .and_then(|m| m.as_str().parse::<u8>().ok())
            .unwrap_or(50);

        // Parse is_safe
        let is_safe = Regex::new(r"IS_SAFE:\s*(true|false)")
            .ok()
            .and_then(|re| re.captures(ultron_response))
            .and_then(|cap| cap.get(1))
            .map(|m| m.as_str() == "true")
            .unwrap_or(false);

        // Parse mitigation
        let mitigation = Regex::new(r"MITIGATION:\s*(.+?)(?:\n[A-Z_]+:|$)")
            .ok()
            .and_then(|re| re.captures(ultron_response))
            .and_then(|cap| cap.get(1))
            .map(|m| m.as_str().trim().to_string())
            .unwrap_or_default();

        AuditResult {
            is_safe,
            risk_score,
            legal_risks: vec![],
            physical_risks: vec![],
            ethical_risks: vec![],
            mitigation,
            raw_response: ultron_response.to_string(),
        }
    }

    pub async fn get_logs(&self) -> Vec<ACSAExecutionLog> {
        self.execution_logs.lock().await.clone()
    }

    pub async fn get_global_stats(&self) -> Result<serde_json::Value> {
        let moss_stats = self.moss.stats().await;
        let l6_stats = self.l6.stats().await;
        let ultron_stats = self.ultron.stats().await;
        let omega_stats = self.omega.stats().await;

        let logs = self.execution_logs.lock().await;

        Ok(serde_json::json!({
            "moss": moss_stats,
            "l6": l6_stats,
            "ultron": ultron_stats,
            "omega": omega_stats,
            "total_executions": logs.len(),
            "successful_executions": logs.iter().filter(|l| l.success).count(),
        }))
    }
}
